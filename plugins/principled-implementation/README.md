<p align="center">
  <strong>ğŸš€ principled-implementation</strong>
</p>

<p align="center">
  <em>Orchestrate DDD plan execution via worktree-isolated Claude Code agents.</em>
</p>

<p align="center">
  <img src="https://img.shields.io/badge/claude_code-v2.1.3+-7c3aed?style=flat-square" alt="Claude Code v2.1.3+" />
  <img src="https://img.shields.io/badge/version-0.1.0-blue?style=flat-square" alt="Version 0.1.0" />
  <img src="https://img.shields.io/badge/status-active-brightgreen?style=flat-square" alt="Status: Active" />
  <img src="https://img.shields.io/badge/license-MIT-gray?style=flat-square" alt="License: MIT" />
</p>

---

A Claude Code plugin that bridges the gap between **planning** and **execution** in specification-first development. It reads DDD implementation plans generated by the [principled-docs](../principled-docs/) plugin and automates their execution â€” decomposing tasks, spawning isolated agents, validating results, and merging work back.

## ğŸ”­ The Lifecycle

Every plan follows four stages:

```mermaid
flowchart LR
    D["ğŸ“¦ <b>Decompose</b><br/><i>plan â†’ tasks</i><br/><br/>Parse Â· Order Â· Manifest"]
    S["ğŸš€ <b>Spawn</b><br/><i>task â†’ agent</i><br/><br/>Worktree Â· Isolated"]
    V["âœ… <b>Validate</b><br/><i>checks pass?</i><br/><br/>Test Â· Lint Â· Build"]
    M["ğŸ”€ <b>Merge</b><br/><i>branch â†’ main</i><br/><br/>Merge Â· Cleanup"]

    D --> S --> V --> M
```

**Decompose** extracts tasks from a DDD plan. **Spawn** executes each in an isolated git worktree. **Validate** runs project checks. **Merge** integrates the result and cleans up.

## âš¡ Quick Start

```bash
# Install the plugin
claude plugin add <path-to-principled-implementation>

# Or run the full pipeline automatically
/orchestrate docs/plans/003-new-feature.md

# Step-by-step alternative:
/decompose docs/plans/003-new-feature.md   # extract tasks
/spawn 1.1                                  # execute a task
/check-impl --task 1.1                      # validate it
/merge-work 1.1                             # merge back
```

## ğŸ› ï¸ Skills

6 skills, each a slash command. Each skill is self-contained â€” its own templates, scripts, and reference docs.

### Orchestration

| Command                                             | Description                                                       |
| --------------------------------------------------- | ----------------------------------------------------------------- |
| `/orchestrate <plan-path> [--phase N] [--continue]` | ğŸ¯ Full automated lifecycle: decompose â†’ spawn â†’ validate â†’ merge |
| `/spawn <task-id>`                                  | ğŸš€ Execute a task in an isolated worktree via impl-worker agent   |
| `/merge-work <task-id> [--force] [--no-cleanup]`    | ğŸ”€ Merge a validated task's branch and clean up                   |

### Analysis

| Command                             | Description                                        |
| ----------------------------------- | -------------------------------------------------- |
| `/decompose <plan-path>`            | ğŸ“¦ Extract tasks from a DDD plan into a manifest   |
| `/check-impl [--task <id>] [--all]` | âœ… Validate implementations against project checks |

### Background Knowledge

`impl-strategy` â€” not directly invocable. Gives Claude Code deep understanding of the orchestration strategy, task lifecycle, manifest schema, and worktree isolation model. Activates automatically when working with implementations.

## ğŸ¤– Agents

| Agent         | Isolation  | Description                                                    |
| ------------- | ---------- | -------------------------------------------------------------- |
| `impl-worker` | `worktree` | Executes a single task from a DDD plan in an isolated worktree |

The `spawn` skill delegates to `impl-worker` via `context: fork` + `agent: impl-worker` frontmatter. Each agent gets its own git worktree, creates a named branch (`impl/<plan-number>/<task-id>`), implements the task, and commits.

## ğŸ”’ Enforcement Hooks

One advisory hook â€” no manual action required.

| Hook                            | Trigger                  | Behavior                                                                              |
| ------------------------------- | ------------------------ | ------------------------------------------------------------------------------------- |
| **Manifest Integrity Advisory** | PreToolUse `Edit\|Write` | ğŸ’¡ Warns when `.impl/manifest.json` is edited directly. Advisory only â€” never blocks. |

## ğŸ—ï¸ Architecture

The plugin is built in three layers:

```mermaid
flowchart TB
    S["ğŸ› ï¸ <b>SKILLS</b> â€” orchestration workflows<br/>6 skills, each self-contained"]
    A["ğŸ¤– <b>AGENTS</b> â€” worktree-isolated execution<br/>impl-worker Â· fork context"]
    F["ğŸ§± <b>FOUNDATION</b> â€” scripts, templates, manifest<br/>3 canonical scripts Â· 1 canonical template"]

    S --> A --> F
```

### Worktree Isolation

```
/orchestrate (inline)
  â”œâ”€â”€ Decompose plan â†’ .impl/manifest.json
  â”œâ”€â”€ For each phase (sequential):
  â”‚   â”œâ”€â”€ For each task:
  â”‚   â”‚   â”œâ”€â”€ /spawn <task-id> â†’ impl-worker agent (worktree)
  â”‚   â”‚   â”œâ”€â”€ /check-impl â†’ run project checks
  â”‚   â”‚   â””â”€â”€ /merge-work â†’ merge branch, cleanup
  â”‚   â””â”€â”€ Phase complete
  â””â”€â”€ Final summary
```

Key constraints:

- **Subagents cannot spawn subagents.** The orchestrator runs inline to coordinate multiple `/spawn` calls sequentially.
- **Worktree agents cannot access main worktree files.** Task details are embedded in the agent prompt via `!` backtick pre-fork commands.
- **The manifest tracks all state.** `.impl/manifest.json` is managed by scripts and the orchestrator â€” not by worktree agents.

### Error Recovery

- **Failed checks**: retry up to 2 times with failure context
- **Merge conflicts**: pause for manual resolution, resume with `--continue`
- **Interrupted**: resume from manifest state with `--continue`

## ğŸ”„ Script Duplication

Following the principled convention, shared scripts are duplicated across consuming skills with byte-identical copies. A drift check verifies all copies match:

```bash
bash plugins/principled-implementation/scripts/check-template-drift.sh
```

| Canonical                            | Copies To                                                      |
| ------------------------------------ | -------------------------------------------------------------- |
| `decompose/scripts/parse-plan.sh`    | `orchestrate/scripts/`                                         |
| `decompose/scripts/task-manifest.sh` | `spawn/`, `check-impl/`, `merge-work/`, `orchestrate/` scripts |
| `check-impl/scripts/run-checks.sh`   | `orchestrate/scripts/`                                         |
| `spawn/templates/claude-task.md`     | `orchestrate/templates/`                                       |

## ğŸš€ CI Integration

### Template Drift Check

```yaml
- name: Check implementation template drift
  run: bash plugins/principled-implementation/scripts/check-template-drift.sh
```

Exits non-zero if any script or template copy has diverged from canonical.

### Hook Smoke-test

```yaml
- name: Smoke-test manifest integrity hook
  run: |
    echo '{"tool_input":{"file_path":".impl/manifest.json"}}' \
      | bash plugins/principled-implementation/hooks/scripts/check-manifest-integrity.sh
    echo '{"tool_input":{"file_path":"src/index.ts"}}' \
      | bash plugins/principled-implementation/hooks/scripts/check-manifest-integrity.sh
```

Both must exit 0 â€” the hook is advisory only.

## ğŸ“¦ Dependencies

- **Claude Code v2.1.3+** (skills, agents, worktree isolation)
- **Bash** (all scripts are pure bash)
- **Git** (worktree management)
- **jq** (optional â€” scripts fall back to grep/sed)

---

<p align="center">
  <sub>Built with the <a href="https://docs.anthropic.com/en/docs/claude-code">Claude Code</a> plugin system Â· Principled specification-first methodology</sub>
</p>
